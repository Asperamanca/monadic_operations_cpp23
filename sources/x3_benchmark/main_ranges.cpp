#include "benchmark.h"
#include "ctrack.hpp"
#include <vector>
#include <numeric>
#include <iostream>
#include "benchmarkranges.h"
#include "configureranges.h"
#include "parsecommandline.h"

// BENCHMARK FOR RANGE PROCESSING
//
// Input is filled with numbers 1..size (std::iota)
// Intermediate values are generated by creating an iota again for each number:
//  1 -> 1
//  2 -> 1,2
//  3 -> 1,2,3
// etc.
// This is done with 3 levels of nesting, so
//  3 -> 1,2,3 -> 1,1,2,1,2,3 -> 1,1,1,2,1,1,2,1,2,3
// etc.
// This blows up the intermediate range nicely in a fashion that is not deterministic in order
//  (because the original input is random_shuffle'd every time)
//  but that is deterministic in which values exist.
//
// Then, the intermediate values are folded to a single result, the results collected,
//  summed up and averaged, and the final result printed.
// The point of the exercise is to prevent the compiler from optimizing away the whole loop
//  (which might happen if the results were never used, for example)
//
// Only the segment which calculates the per-iteration result from the initial input is benchmarked.
//
// The different implementations are:
//  1: Classic loop to build intermediate vector, loop to accumulate result
//  2: Same as (1), but with a pre-allocated vector
//  3: Classic loop with integrated accumulation of final result
//  4: Create view on intermediate range, loop to accumulate result
//  5: Like (1), but use a view to build the initial vector
//
// Choose the test to run via command line (just the number, nothing else)
//
// Further configuration (input length, number of iteration) can be made, see "configuration.h"


// Make sure to run the benchmark with optimization (-O2 or more)
//  std::ranges::views are terribly slow in debug builds
int main(int argc, char* argv[])
{
    using namespace mop;

    std::vector<int> rangesInput(s_RangesInputLength);
    std::iota(rangesInput.begin(), rangesInput.end(),1);

    static constexpr auto s_IncorrectTestNumberMessage =  "Please specify test number:\n"
                                                          "1: Classic loop to build intermediate vector, loop to accumulate result\n"
                                                          "2: Same as (1), but with a pre-allocated vector\n"
                                                          "3: Classic loop with integrated accumulation of final result\n"
                                                          "4: Create view on intermediate range, loop to accumulate result\n"
                                                          "5: Like (1), but use a view to build the initial vector\n";

    const auto oTestNumber = getNumberFromCmdLine(argc, argv, 1);
    if ( ! oTestNumber )
    {
        std::cout << s_IncorrectTestNumberMessage;
        return 1;
    }

    switch (*oTestNumber)
    {
        case 1: benchmark("Ranges_Classic"          ,accumulatePlusMinusExpandedIotaClassic            ,rangesInput,s_RangesIterations); break;
        case 2: benchmark("Ranges_ClassicPrealloc"  ,accumulatePlusMinusExpandedIotaClassicPreallocate ,rangesInput,s_RangesIterations); break;
        case 3: benchmark("Ranges_ClassicIntegrated",accumulatePlusMinusExpandedIotaClassicIntegrated  ,rangesInput,s_RangesIterations); break;
        case 4: benchmark("Ranges_Views"            ,accumulatePlusMinusExpandedIotaViews              ,rangesInput,s_RangesIterations); break;
        case 5: benchmark("Ranges_ViewsToVector"    ,accumulatePlusMinusExpandedIotaViewsToVector      ,rangesInput,s_RangesIterations); break;
        default:
        {
            std::cout << s_IncorrectTestNumberMessage;
            return 1;
        }
    }

    ctrack::result_print();

    return 0;
}


